package edu.iastate.cs472.proj1;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 *
 * @author Abhay Prasanna Rao
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below:
 *
 *  1 2 3
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object
 * of the State class.
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles

	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state

	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states.

	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the
	                                        // goal state; negative if not computed yet.
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double
										    // move counted as one; negative if not computed yet.


	public static final int[][] GOAL_STATE = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
	/**
	 * Constructor (for the initial state).
	 *
	 * It takes a 2-dimensional array representing an initial board configuration. The empty
	 * square is represented by the number 0.
	 *
	 *     a) Initialize all three links previous, next, and predecessor to null.
	 *     b) Set move to null and numMoves to zero.
	 *
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are
	 * 										not respectively the digits 0, 1, ..., 8.
	 */
    public State(int[][] board) throws IllegalArgumentException
    {
		if (board.length != 3 || board[0].length != 3) {
			throw new IllegalArgumentException("This board must be a 3x3 matrix.");
		}
		this.board = board;
		predecessor = null;
		previous = null;
		next = null;
		move = null;
		numMoves = 0;
	}


    /**
     * Constructor (for the initial state)
     *
     * It takes a state from an input file that has three rows, each containing three digits
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are
     * from 0 to 8 with no duplicates.
     *
     * Do the same initializations as for the first constructor.
     *
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements.
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
		File file = new File(inputFileName);
		Scanner scanner = new Scanner(file);
		board = new int[3][3];
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				if (scanner.hasNextInt()) {
					board[i][j] = scanner.nextInt();
				} else {
					throw new IllegalArgumentException("Invalid file format.");
				}
			}
		}
		scanner.close();
		if (!validateBoard(board)) {
			throw new IllegalArgumentException("Invalid board configuration.");
		}
		this.board = board;
	}
	private boolean validateBoard(int[][] board) {
		boolean[] seen = new boolean[9];
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				int value = board[row][col];
				if (value < 0 || value > 8 || seen[value]) {
					return false;
				}
				seen[value] = true;
			}
		}
		return true;
	}

    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the
     * following:
     *
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m;
     *     c) Set the links next and previous to null;
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1.
     *
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or
     *                                  if DBL_RIGHT when the empty square is not in the right column, or
     *                                  if DBL_UP when the empty square is not in the top row, or
     *                                  if DBL_DOWN when the empty square is not in the bottom row.
     */
	public State successorState(Move m) throws IllegalArgumentException {
		int[] emptyPos = findEmptyTile();
		int row = emptyPos[0], col = emptyPos[1];

		State successor = (State) this.clone();
		successor.predecessor = this;
		successor.move = m;
		successor.numMoves = this.numMoves + 1;

		int newRow = row, newCol = col;
		switch (m) {
			case LEFT:
				if (col == 2) throw new IllegalArgumentException("Cannot move left");
				newCol++;
				break;
			case RIGHT:
				if (col == 0) throw new IllegalArgumentException("Cannot move right");
				newCol--;
				break;
			case UP:
				if (row == 2) throw new IllegalArgumentException("Cannot move up");
				newRow++;
				break;
			case DOWN:
				if (row == 0) throw new IllegalArgumentException("Cannot move down");
				newRow--;
				break;
			case DBL_LEFT:
				if (col >= 1) throw new IllegalArgumentException("Cannot double move left");
				newCol += 2;
				break;
			case DBL_RIGHT:
				if (col <= 1) throw new IllegalArgumentException("Cannot double move right");
				newCol -= 2;
				break;
			case DBL_UP:
				if (row >= 1) throw new IllegalArgumentException("Cannot double move up");
				newRow += 2;
				break;
			case DBL_DOWN:
				if (row <= 1) throw new IllegalArgumentException("Cannot double move down");
				newRow -= 2;
				break;
		}

		successor.board[row][col] = successor.board[newRow][newCol];
		successor.board[newRow][newCol] = 0;


		return successor;
	}

	private int[] findEmptyTile() {
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				if (board[i][j] == 0) {
					return new int[]{i, j};
				}
			}
		}
		throw new IllegalStateException("No empty tile found");
	}


    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration.
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number
     * of inversions.
     */
    /**
     *
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
	public boolean solvable() {
		int[] sequence = compute_inversion();
		int inversions = 0;
		int blankRow = 0;
		for (int i = 0; i < 9; i++) {
			if (sequence[i] == 0) {
				blankRow = 2 - (i / 3); // Count from bottom
			}
			for (int j = i + 1; j < 9; j++) {
				if (sequence[i] > sequence[j] && sequence[i] != 0 && sequence[j] != 0) {
					inversions++;
				}
			}
		}
		return (inversions % 2 == 0) == (blankRow % 2 == 1);
	}
	public int[] compute_inversion() {
		int[] sequence = new int[9];
		int index = 0;
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				sequence[index++] = board[row][col];
			}
		}
		return sequence;
	}


    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents:
     *
     * 		1 2 3
     * 		8 0 4
     * 		7 6 5
     *
     * @return
     */
    public boolean isGoalState()
    {
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				if (board[row][col] != GOAL_STATE[row][col]) {
					return false;
				}
			}
		}
		return true;
    }


    /**
     * Write the board configuration according to the following format:
     *
     *     a) Output row by row in three lines with no indentations.
     *     b) Two adjacent tiles in each row have exactly one blank in between.
     *     c) The empty square is represented by a blank.
     *
     * For example,
     *
     * 2   3
     * 1 8 4
     * 7 6 5
     *
     */
    @Override
    public String toString()
    {
		StringBuilder s = new StringBuilder();
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				if (board[row][col] == 0) {
					s.append(' ');
				} else {
					s.append(board[row][col]);
				}
				s.append(' ');
			}
			s.append('\n');
		}
		return s.toString();
    }


    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null.
     *
     * The method is called by SuccessorState();
     */
    @Override
    public Object clone()
    {
		try {
			State cloned = (State) super.clone();
			cloned.board = new int[3][3];
			for (int i = 0; i < 3; i++) {
				System.arraycopy(this.board[i], 0, cloned.board[i], 0, 3);
			}
			return cloned;
		} catch (CloneNotSupportedException e) {
			throw new InternalError(e);
		}
    }


    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][]
     * have the same content.
     */
    @Override
    public boolean equals(Object o)
    {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		State state = (State) o;
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				if (board[i][j] != state.board[i][j]) {
					return false;
				}
			}
		}
		return true;
    }


    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and
     * the estimated number of moves to the goal state using the heuristic stored in the instance
     * variable heu.
     *
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance().
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves().
     *
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic.
     */
    public int cost() throws IllegalArgumentException
    {
		if (heu == Heuristic.TileMismatch) {
			return numMoves + computeNumMismatchedTiles();
		} else if (heu == Heuristic.ManhattanDist) {
			return numMoves + computeManhattanDistance();
		} else if (heu == Heuristic.DoubleMoveHeuristic) {
			return numMoves + computeNumSingleDoubleMoves();
		} else {
			throw new IllegalArgumentException();
		}
    }


    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     *
     * @return -1 if c1 < c2
     *          0 if c1 = c2
     *          1 if c1 > c2
     *
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
		return Integer.compare(this.cost(), s.cost());
    }


    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its
     * value otherwise.
     *
     * @return the number of mismatched tiles between this state and the goal state.
     */

	private int computeNumMismatchedTiles() {
		if (numMismatchedTiles >= 0) {
			return numMismatchedTiles;
		}
		numMismatchedTiles = 0;
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				if (board[row][col] != 0 && board[row][col] != GOAL_STATE[row][col]) {
					numMismatchedTiles++;
				}
			}
		}
		return numMismatchedTiles;
	}


	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value
	 * otherwise.
	 *
	 * @return the Manhattan distance between this state and the goal state.
	 */

	private int computeManhattanDistance() {
		if (ManhattanDistance >= 0) {
			return ManhattanDistance;
		}
		ManhattanDistance = 0;
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				int value = board[row][col];
				if (value != 0) {
					int goalRow = (value - 1) / 3;
					int goalCol = (value - 1) % 3;
					ManhattanDistance += Math.abs(row - goalRow) + Math.abs(col - goalCol);
				}
			}
		}
		return ManhattanDistance;
	}


	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value
	 * otherwise.
	 *
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves,
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves() {
		if (numSingleDoubleMoves >= 0) {
			return numSingleDoubleMoves;
		}
		int count = 0;
		for (int row = 0; row < 3; row++) {
			for (int col = 0; col < 3; col++) {
				int value = board[row][col];
				if (value != 0) {
					int goalRow = (value - 1) / 3;
					int goalCol = (value - 1) % 3;
					int rowDiff = Math.abs(row - goalRow);
					int colDiff = Math.abs(col - goalCol);
					count += Math.max((rowDiff + 1) / 2, (colDiff + 1) / 2);
				}
			}
		}
		numSingleDoubleMoves = count;
		return count;
	}
}
